# Issue #002: 学校基本情報・役職情報API実装

## 概要

Issue #001「学校基本情報画面の実装」に対応するバックエンドAPIを実装する。学校情報と役職情報を管理するためのAPIエンドポイントを追加し、データベースとの連携を行う。

## 現在の状況

現在のモックバックエンド（`/mock_backend/app.py`）には以下のAPIが実装されている：
- クラス情報API
- 図書室情報API
- 図書委員情報API
- スケジュール関連API

しかし、学校情報と役職情報を扱うAPIがまだ実装されていない。

## 変更内容

### 更新ファイル

1. **アプリケーションコード**
   - `/mock_backend/app.py` - 学校情報と役職情報のAPIエンドポイント追加

2. **データベーススキーマ**
   - `/mock_backend/db_setup.py` - 必要に応じてスキーマの更新
   - `/mock_backend/init_database.py` - 初期データの追加

3. **テストコード**
   - `/mock_backend/test_api.py` - 新しいAPIエンドポイントのテスト追加

## API仕様詳細

### 学校情報API

#### 1. 学校情報の取得 (GET /api/schools)

**レスポンス**:
```json
[
  {
    "id": 1,
    "school_name": "中央中学校",
    "first_term_start": "2025-04-01",
    "first_term_end": "2025-09-30",
    "second_term_start": "2025-10-01",
    "second_term_end": "2026-03-31",
    "active": true,
    "created_at": "2025-05-25T00:00:00",
    "updated_at": "2025-05-25T00:00:00"
  }
]
```

#### 2. 学校情報の新規作成 (POST /api/schools)

**リクエスト**:
```json
{
  "school_name": "東部中学校",
  "first_term_start": "2025-04-01",
  "first_term_end": "2025-09-30",
  "second_term_start": "2025-10-01",
  "second_term_end": "2026-03-31",
  "active": true
}
```

**レスポンス** (201 Created):
```json
{
  "id": 2,
  "school_name": "東部中学校",
  "first_term_start": "2025-04-01",
  "first_term_end": "2025-09-30",
  "second_term_start": "2025-10-01",
  "second_term_end": "2026-03-31",
  "active": true,
  "created_at": "2025-05-26T00:00:00",
  "updated_at": "2025-05-26T00:00:00"
}
```

#### 3. 学校情報の更新 (PUT /api/schools/:id)

**リクエスト**:
```json
{
  "school_name": "東部第二中学校",
  "first_term_start": "2025-04-05",
  "active": false
}
```

**レスポンス** (200 OK):
```json
{
  "id": 2,
  "school_name": "東部第二中学校",
  "first_term_start": "2025-04-05",
  "first_term_end": "2025-09-30",
  "second_term_start": "2025-10-01",
  "second_term_end": "2026-03-31",
  "active": false,
  "created_at": "2025-05-26T00:00:00",
  "updated_at": "2025-05-26T01:00:00"
}
```

### 役職情報API

#### 1. 役職一覧の取得 (GET /api/positions)

**レスポンス**:
```json
[
  {
    "id": 1,
    "position_name": "委員長",
    "description": "図書委員会の代表者",
    "created_at": "2025-05-25T00:00:00",
    "updated_at": "2025-05-25T00:00:00"
  },
  {
    "id": 2,
    "position_name": "副委員長",
    "description": "委員長の補佐",
    "created_at": "2025-05-25T00:00:00",
    "updated_at": "2025-05-25T00:00:00"
  }
]
```

#### 2. 特定の役職の取得 (GET /api/positions/:id)

**レスポンス**:
```json
{
  "id": 1,
  "position_name": "委員長",
  "description": "図書委員会の代表者",
  "created_at": "2025-05-25T00:00:00",
  "updated_at": "2025-05-25T00:00:00"
}
```

#### 3. 役職の新規作成 (POST /api/positions)

**リクエスト**:
```json
{
  "position_name": "書記",
  "description": "会議の記録を担当"
}
```

**レスポンス** (201 Created):
```json
{
  "id": 3,
  "position_name": "書記",
  "description": "会議の記録を担当",
  "created_at": "2025-05-26T00:00:00",
  "updated_at": "2025-05-26T00:00:00"
}
```

#### 4. 役職の更新 (PUT /api/positions/:id)

**リクエスト**:
```json
{
  "description": "図書委員会の書記として会議の議事録を管理"
}
```

**レスポンス** (200 OK):
```json
{
  "id": 3,
  "position_name": "書記",
  "description": "図書委員会の書記として会議の議事録を管理",
  "created_at": "2025-05-26T00:00:00",
  "updated_at": "2025-05-26T01:00:00"
}
```

#### 5. 役職の削除 (DELETE /api/positions/:id)

**レスポンス** (200 OK):
```json
{
  "message": "Position with id 3 successfully deleted"
}
```

## バックエンド実装詳細

### 学校情報API実装
```python
# --- API Endpoints for Schools ---

@app.route('/api/schools', methods=['GET'])
def get_schools():
    conn = get_db_connection()
    schools_cursor = conn.execute('SELECT * FROM schools')
    schools = [dict(row) for row in schools_cursor.fetchall()]
    conn.close()
    return jsonify(schools)

@app.route('/api/schools', methods=['POST'])
def add_school():
    new_school_data = request.json
    if not new_school_data or 'school_name' not in new_school_data:
        return jsonify({"error": "Missing school_name in request body"}), 400

    school_name = new_school_data['school_name']
    first_term_start = new_school_data.get('first_term_start')
    first_term_end = new_school_data.get('first_term_end')
    second_term_start = new_school_data.get('second_term_start')
    second_term_end = new_school_data.get('second_term_end')
    active = new_school_data.get('active', True)

    conn = get_db_connection()
    cursor = conn.cursor()
    try:
        cursor.execute('''
            INSERT INTO schools (
                school_name, first_term_start, first_term_end, 
                second_term_start, second_term_end, active
            ) VALUES (?, ?, ?, ?, ?, ?)
        ''', (school_name, first_term_start, first_term_end, 
              second_term_start, second_term_end, active))
        conn.commit()
        new_school_id = cursor.lastrowid
        
        # Get the created school with timestamps
        cursor.execute('SELECT * FROM schools WHERE id = ?', (new_school_id,))
        created_school = dict(cursor.fetchone())
    except sqlite3.IntegrityError:
        conn.close()
        return jsonify({"error": "Failed to create school, possibly due to constraint violation"}), 409
    finally:
        conn.close()

    return jsonify(created_school), 201

@app.route('/api/schools/<int:school_id>', methods=['PUT'])
def update_school(school_id):
    update_data = request.json
    if not update_data:
        return jsonify({"error": "Request body cannot be empty"}), 400

    conn = get_db_connection()
    cursor = conn.cursor()

    # Check if school exists
    cursor.execute('SELECT * FROM schools WHERE id = ?', (school_id,))
    school = cursor.fetchone()
    if not school:
        conn.close()
        return jsonify({"error": "School not found"}), 404

    # Prepare update fields and values
    fields_to_update = []
    values = []
    
    for field in ['school_name', 'first_term_start', 'first_term_end', 
                  'second_term_start', 'second_term_end', 'active']:
        if field in update_data:
            fields_to_update.append(f"{field} = ?")
            values.append(update_data[field])
    
    if not fields_to_update:
        conn.close()
        return jsonify({"error": "No valid fields to update provided"}), 400
    
    # Add updated_at field
    fields_to_update.append("updated_at = CURRENT_TIMESTAMP")
    
    # Create SQL query
    sql = f"UPDATE schools SET {', '.join(fields_to_update)} WHERE id = ?"
    values.append(school_id)
    
    try:
        cursor.execute(sql, values)
        conn.commit()
        
        # Get the updated school
        cursor.execute('SELECT * FROM schools WHERE id = ?', (school_id,))
        updated_school = dict(cursor.fetchone())
    except sqlite3.Error as e:
        conn.close()
        return jsonify({"error": f"Failed to update school: {str(e)}"}), 500
    finally:
        conn.close()
        
    return jsonify(updated_school)
```

### 役職情報API実装
```python
# --- API Endpoints for Positions ---

@app.route('/api/positions', methods=['GET'])
def get_positions():
    conn = get_db_connection()
    positions_cursor = conn.execute('SELECT * FROM positions')
    positions = [dict(row) for row in positions_cursor.fetchall()]
    conn.close()
    return jsonify(positions)

@app.route('/api/positions/<int:position_id>', methods=['GET'])
def get_position(position_id):
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute('SELECT * FROM positions WHERE id = ?', (position_id,))
    position = cursor.fetchone()
    conn.close()
    
    if position is None:
        return jsonify({"error": "Position not found"}), 404
        
    return jsonify(dict(position))

@app.route('/api/positions', methods=['POST'])
def add_position():
    new_position_data = request.json
    if not new_position_data or 'position_name' not in new_position_data:
        return jsonify({"error": "Missing position_name in request body"}), 400

    position_name = new_position_data['position_name']
    description = new_position_data.get('description')

    conn = get_db_connection()
    cursor = conn.cursor()
    try:
        cursor.execute('INSERT INTO positions (position_name, description) VALUES (?, ?)', 
                      (position_name, description))
        conn.commit()
        new_position_id = cursor.lastrowid
        
        # Get the created position with timestamps
        cursor.execute('SELECT * FROM positions WHERE id = ?', (new_position_id,))
        created_position = dict(cursor.fetchone())
    except sqlite3.IntegrityError:
        conn.close()
        return jsonify({"error": "Failed to create position, possibly due to constraint violation"}), 409
    finally:
        conn.close()

    return jsonify(created_position), 201

@app.route('/api/positions/<int:position_id>', methods=['PUT'])
def update_position(position_id):
    update_data = request.json
    if not update_data:
        return jsonify({"error": "Request body cannot be empty"}), 400

    conn = get_db_connection()
    cursor = conn.cursor()

    # Check if position exists
    cursor.execute('SELECT * FROM positions WHERE id = ?', (position_id,))
    position = cursor.fetchone()
    if not position:
        conn.close()
        return jsonify({"error": "Position not found"}), 404

    # Prepare update fields and values
    fields_to_update = []
    values = []
    
    for field in ['position_name', 'description']:
        if field in update_data:
            fields_to_update.append(f"{field} = ?")
            values.append(update_data[field])
    
    if not fields_to_update:
        conn.close()
        return jsonify({"error": "No valid fields to update provided"}), 400
    
    # Add updated_at field
    fields_to_update.append("updated_at = CURRENT_TIMESTAMP")
    
    # Create SQL query
    sql = f"UPDATE positions SET {', '.join(fields_to_update)} WHERE id = ?"
    values.append(position_id)
    
    try:
        cursor.execute(sql, values)
        conn.commit()
        
        # Get the updated position
        cursor.execute('SELECT * FROM positions WHERE id = ?', (position_id,))
        updated_position = dict(cursor.fetchone())
    except sqlite3.Error as e:
        conn.close()
        return jsonify({"error": f"Failed to update position: {str(e)}"}), 500
    finally:
        conn.close()
        
    return jsonify(updated_position)

@app.route('/api/positions/<int:position_id>', methods=['DELETE'])
def delete_position(position_id):
    conn = get_db_connection()
    cursor = conn.cursor()
    
    # Check if position exists
    cursor.execute('SELECT * FROM positions WHERE id = ?', (position_id,))
    position = cursor.fetchone()
    if not position:
        conn.close()
        return jsonify({"error": "Position not found"}), 404
    
    # Check if the position is referenced by any committee members
    cursor.execute('SELECT COUNT(*) FROM committee_members WHERE position_id = ?', (position_id,))
    count = cursor.fetchone()[0]
    if count > 0:
        conn.close()
        return jsonify({"error": "Cannot delete position as it is assigned to committee members"}), 409
    
    # Delete the position
    try:
        cursor.execute('DELETE FROM positions WHERE id = ?', (position_id,))
        conn.commit()
    except sqlite3.Error as e:
        conn.close()
        return jsonify({"error": f"Failed to delete position: {str(e)}"}), 500
    finally:
        conn.close()
    
    return jsonify({"message": f"Position with id {position_id} successfully deleted"})
```

## データベーススキーマ更新

既存のデータベーススキーマを確認し、必要に応じて更新します。`db_setup.py`に以下のテーブル定義を追加・確認します：

```python
# schools テーブルの作成
cursor.execute('''
CREATE TABLE IF NOT EXISTS schools (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    school_name TEXT NOT NULL UNIQUE,
    first_term_start DATE,
    first_term_end DATE,
    second_term_start DATE,
    second_term_end DATE,
    active BOOLEAN NOT NULL DEFAULT TRUE,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
)
''')

# positions テーブルの作成
cursor.execute('''
CREATE TABLE IF NOT EXISTS positions (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    position_name TEXT NOT NULL UNIQUE,
    description TEXT,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
)
''')
```

## 初期データ投入

`init_database.py`に以下の初期データを追加します：

```python
# 学校テーブル初期データ
cursor.execute('''
INSERT INTO schools (school_name, first_term_start, first_term_end, second_term_start, second_term_end)
VALUES ('中央中学校', '2025-04-01', '2025-09-30', '2025-10-01', '2026-03-31')
''')

# 役職テーブル初期データ
cursor.execute('''
INSERT INTO positions (position_name, description) VALUES 
('委員長', '図書委員会の代表者'),
('副委員長', '委員長の補佐'),
('書記', '書記')
''')
```

## テスト仕様

`test_api.py`に以下のテストケースを追加します：

```python
# 学校情報APIのテスト
def test_get_schools():
    response = client.get('/api/schools')
    assert response.status_code == 200
    data = response.json
    assert isinstance(data, list)
    if len(data) > 0:
        assert 'school_name' in data[0]

def test_create_school():
    new_school = {
        "school_name": "テスト中学校",
        "first_term_start": "2025-04-01",
        "first_term_end": "2025-09-30"
    }
    response = client.post('/api/schools', json=new_school)
    assert response.status_code == 201
    data = response.json
    assert data['school_name'] == new_school['school_name']
    assert 'id' in data

def test_update_school():
    # 最初に学校を取得
    schools_response = client.get('/api/schools')
    schools_data = schools_response.json
    if len(schools_data) == 0:
        # テスト学校を作成
        test_create_school()
        schools_response = client.get('/api/schools')
        schools_data = schools_response.json
    
    school_id = schools_data[0]['id']
    update_data = {
        "school_name": "更新テスト中学校"
    }
    response = client.put(f'/api/schools/{school_id}', json=update_data)
    assert response.status_code == 200
    data = response.json
    assert data['school_name'] == update_data['school_name']

# 役職情報APIのテスト
def test_get_positions():
    response = client.get('/api/positions')
    assert response.status_code == 200
    data = response.json
    assert isinstance(data, list)
    if len(data) > 0:
        assert 'position_name' in data[0]

def test_get_position_by_id():
    # 最初に役職一覧を取得
    positions_response = client.get('/api/positions')
    positions_data = positions_response.json
    if len(positions_data) == 0:
        # テスト役職を作成
        test_create_position()
        positions_response = client.get('/api/positions')
        positions_data = positions_response.json
    
    position_id = positions_data[0]['id']
    response = client.get(f'/api/positions/{position_id}')
    assert response.status_code == 200
    data = response.json
    assert data['id'] == position_id

def test_create_position():
    new_position = {
        "position_name": "テスト役職",
        "description": "テスト用の役職説明"
    }
    response = client.post('/api/positions', json=new_position)
    assert response.status_code == 201
    data = response.json
    assert data['position_name'] == new_position['position_name']
    assert 'id' in data

def test_update_position():
    # 最初に役職を取得
    positions_response = client.get('/api/positions')
    positions_data = positions_response.json
    if len(positions_data) == 0:
        # テスト役職を作成
        test_create_position()
        positions_response = client.get('/api/positions')
        positions_data = positions_response.json
    
    position_id = positions_data[0]['id']
    update_data = {
        "description": "更新されたテスト説明"
    }
    response = client.put(f'/api/positions/{position_id}', json=update_data)
    assert response.status_code == 200
    data = response.json
    assert data['description'] == update_data['description']

def test_delete_position():
    # テスト用の役職を作成
    new_position = {
        "position_name": "削除テスト役職",
        "description": "削除テスト用の役職"
    }
    create_response = client.post('/api/positions', json=new_position)
    position_id = create_response.json['id']
    
    # 作成した役職を削除
    response = client.delete(f'/api/positions/{position_id}')
    assert response.status_code == 200
    data = response.json
    assert "successfully deleted" in data["message"]
    
    # 削除した役職が取得できないことを確認
    get_response = client.get(f'/api/positions/{position_id}')
    assert get_response.status_code == 404
```

## 完了条件

1. 学校情報APIの全エンドポイントが実装され、正常に動作する
2. 役職情報APIの全エンドポイントが実装され、正常に動作する
3. データベーススキーマが更新され、初期データが投入されている
4. すべてのAPIテストが成功する

## 関連Issue

- Issue #001: 学校基本情報画面の実装（図書室管理・クラス管理を含む）
