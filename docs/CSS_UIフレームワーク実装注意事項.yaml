# TailwindCSSとNext.jsの設定に関する実装時の注意事項

作業内容:
  - TailwindCSSの設定ファイルの修正:
    - CommonJS形式を使用する（module.exports = {}）
    - 正しいプラグインの参照方法を使用する（require()）
    - 適切なバージョンのTailwindCSSを使用する（v3系）
  
  - PostCSSの設定ファイルの修正:
    - CommonJS形式を使用する（module.exports = {}）
    - 正しいプラグイン名を使用する（'tailwindcss'）
    - 適切なバージョンのPostCSSを使用する（v8系）
  
  - package.jsonの依存関係の修正:
    - 存在しないパッケージの削除（@tailwindcss/postcss）
    - 互換性のあるバージョンの指定
    - 必要なプラグインの追加

必要なこと:
  - 設定ファイルの形式を統一する:
    - Next.js 13以降ではESモジュール形式もサポートされているが、TailwindCSSの設定ではCommonJS形式が推奨される
    - postcss.config.jsもCommonJS形式で記述する
  
  - 正しいプラグイン参照:
    - TailwindCSSのプラグインは正しい名前で参照する（例：tailwindcss, @tailwindcss/forms）
    - プラグインの読み込みにはrequire()を使用する
  
  - バージョンの互換性確保:
    - TailwindCSS v3系とPostCSS v8系の組み合わせを使用する
    - Next.jsのバージョンに合わせた依存関係を設定する
  
  - スタイルの適用確認:
    - グローバルCSSファイル（globals.css）にTailwindCSSのディレクティブが含まれていることを確認する
    - コンポーネントでTailwindCSSのクラスが正しく使用されていることを確認する

やってはいけないこと:
  - 異なる形式の混在:
    - 同じプロジェクト内でESモジュール形式とCommonJS形式を混在させない
    - 特にTailwindCSSと関連する設定ファイルでは形式を統一する
  
  - 存在しないパッケージの参照:
    - 正確なパッケージ名を使用する（例：@tailwindcss/postcssではなくtailwindcss）
    - 非公式または廃止されたパッケージに依存しない
  
  - 互換性のないバージョンの使用:
    - 最新バージョンが常に最適とは限らない（例：TailwindCSS v4はまだ安定版ではない）
    - バージョン間の互換性を確認せずに更新しない
  
  - 不適切なプラグイン設定:
    - PostCSSプラグインの順序を無視する（例：tailwindcssの前にautoprefixerを配置する）
    - 必要のないプラグインを過剰に追加する

トラブルシューティング:
  - スタイルが適用されない場合:
    - 開発サーバーを再起動する
    - キャッシュをクリアする（npm run dev -- --clear）
    - 依存関係を再インストールする（npm install）
    - ブラウザのキャッシュをクリアする
  
  - ビルドエラーが発生する場合:
    - エラーメッセージを確認して具体的な問題を特定する
    - 設定ファイルの構文エラーを修正する
    - 互換性のある依存関係のバージョンを使用する

# 今回の修正内容
修正したファイル:
  - frontend/tailwind.config.js:
    - ESモジュール形式からCommonJS形式に変更
    - プラグインの読み込み方法をimport()からrequire()に変更
  
  - frontend/postcss.config.js:
    - ESモジュール形式からCommonJS形式に変更
    - プラグイン名を@tailwindcss/postcssからtailwindcssに修正
  
  - frontend/package.json:
    - 存在しないパッケージ@tailwindcss/postcssを削除
    - TailwindCSSのバージョンを4.1.7から3.3.6に変更
    - PostCSSと関連パッケージのバージョンを適切なものに変更

解決した問題:
  - CSSスタイルが適用されない問題
  - 設定ファイルの形式の不一致
  - 存在しないパッケージへの依存
  - 互換性のないバージョンの使用

# shadcn-uiとNext.jsのフォルダ構成ベストプラクティス（2025-05-22追加）

推奨フォルダ構成:
  フォルダ構造:
    src:
      app: "Next.jsのApp Router用のフォルダ"
      components: "再利用可能なコンポーネント"
      lib: "ユーティリティ関数や共通ロジック"
      hooks: "カスタムReactフック"
      types: "TypeScript型定義"
    
    app構造:
      "(auth)": "認証関連の画面（ルートグループ - URLには含まれない）"
      dashboard: "ダッシュボード画面"
      members: "図書委員管理画面"
      schedule: "スケジュール関連画面"
      _components: "アプリケーション固有の非公開コンポーネント"
      layout.tsx: "ルートレイアウト"
      globals.css: "グローバルスタイル"
    
    components構造:
      ui: "shadcn-uiコンポーネント"
      forms: "フォーム関連コンポーネント"
      layouts: "レイアウト関連コンポーネント"

shadcn-ui実装ガイドライン:
  コンポーネント追加方法:
    - "shadcn-uiのCLIを使用する: npx shadcn-ui@latest add [component-name]"
    - "追加されたコンポーネントは自動的にcomponents/ui/に配置される"
  
  新規画面追加時の手順:
    - "適切なルートフォルダをapp/内に作成"
    - "画面固有のコンポーネントはapp/_components/内に配置"
    - "再利用可能なコンポーネントはcomponents/内に配置"
    - "ルートグループを活用して関連画面をグループ化"
  
  コンポーネントのカスタマイズ:
    - "components/ui/内のコンポーネントをカスタマイズする場合は、元のコンポーネントを修正"
    - "大幅なカスタマイズが必要な場合は、新しいコンポーネントとして実装"
  
  スタイリング方法:
    - "TailwindCSSのユーティリティクラスを使用"
    - "複雑なクラス名の結合にはcn()ユーティリティを使用"
    - "変数を使用したスタイリングにはCSS変数を活用"

実装時の注意事項:
  コンポーネントの分離:
    - "単一責任の原則に従い、コンポーネントを適切に分割"
    - "再利用可能なコンポーネントと画面固有のコンポーネントを明確に区別"
  
  型安全性:
    - "すべてのコンポーネントにPropsの型定義を行う"
    - "shadcn-uiコンポーネントの型定義を活用"
  
  パフォーマンス:
    - "不要なレンダリングを避けるためにメモ化を適切に使用"
    - "大きなコンポーネントは遅延ロードを検討"
  
  アクセシビリティ:
    - "shadcn-uiのアクセシビリティ機能を活用"
    - "適切なARIA属性を使用"

今回の修正内容:
  フォルダ構成の改善:
    - "src/components/ui/: shadcn-uiコンポーネント用のフォルダを作成"
    - "src/lib/: ユーティリティ関数用のフォルダを作成"
    - "src/lib/utils.ts: shadcn-uiのユーティリティ関数を実装"
    - "src/app/_components/: アプリケーション固有のコンポーネント用フォルダを作成"
  
  依存関係の追加:
    - "clsx: クラス名の条件付き結合のためのライブラリ"
    - "tailwind-merge: TailwindCSSクラスの競合を解決するライブラリ"
  
  設定ファイルの追加:
    - "components.json: shadcn-uiの設定ファイル"
    - "スタイルや色のテーマを設定"
    - "コンポーネントのエイリアスパスを設定"

# Playwrightテストに関するベストプラクティス（2025-05-22追加）

Playwrightテストの実施方法:
  テストの種類:
    E2Eテスト: "エンドツーエンドのフローをテスト"
    画面遷移テスト: "画面間の遷移が正しく機能するか確認"
    コンポーネントテスト: "個別のコンポーネントの動作をテスト"
  
  テスト実行方法:
    MCPツールの利用: "CascadeのMCPツールを使用してブラウザ操作を実行"
    自動化スクリプト: "Playwrightのスクリプトを作成して自動テストを実行"
  
  テスト結果の記録:
    YAMLファイル: "テスト結果を構造化されたYAML形式で記録"
    スクリーンショット: "重要なステップでスクリーンショットを取得"

Playwrightテストのベストプラクティス:
  テスト設計:
    - "単一責任の原則に従い、テストを小さな単位に分割"
    - "テストケースは明確な目的と期待結果を持つように設計"
  
  セレクタの使用:
    - "テキストや属性に基づく安定したセレクタを使用"
    - "CSSセレクタよりもアクセシビリティに基づくセレクタを優先"
  
  アサーション:
    - "要素の存在、可視性、テキスト内容などを確認"
    - "適切なタイムアウトや待機処理を実装"
  
  テストデータ:
    - "モックデータを使用してテストの信頼性を向上"
    - "テスト間でデータの分離を確保"

実装したPlaywrightテスト:
  画面遷移テスト:
    - "ログイン画面から各画面への遷移をテスト"
    - "ダッシュボードから各機能画面への遷移をテスト"
    - "ログアウト機能の動作をテスト"
  
  テスト結果:
    - "11件のテストケースを実行し、すべて成功"
    - "テスト結果をYAML形式でfrontend/test/navigation_test_results.yamlに保存"
